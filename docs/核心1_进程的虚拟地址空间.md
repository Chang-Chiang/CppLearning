# 进程的虚拟地址空间内存划分和布局

```c++
// 全局变量, 都叫做数据
// 编译后在符号表中都会产生符号
int gdata1 = 10;  // 初始化, 不为 0, 存放在 .data 段
int gdata2 = 0;  // 初始化, 为 0, 存放在 .bss 段
int gdata3;  // 未初始化, 存放在 .bss 段

static int gdata4 = 11;  // 初始化, 不为 0, 存放在 .data 段
static int gdata5 = 0;  // 初始化, 为 0, 存放在 .bss 段
static int gdata6;  // 未初始化, 存放在 .bss 段


int main() {
    
    // 局部变量, 对应产生指令
    // 编译后不会在符号表中产生符号
    int a = 12;  
    // 产生指令 mov dword ptr[a], 0Ch  指令存放在 .text 段
    // 指令运行时, 在栈上开辟空间, 存放 a
    int b = 0;
    int c;
    
    // 静态局部变量, 存放在数据段
    // 程序启动时不会初始化
    // 第一次运行至该点时才会初始化
    static int e = 13;  // 初始化, 不为 0, 存放在 .data 段
    static int f = 0;  // 初始化, 为 0, 存放在 .bss 段
    static int g;  // 未初始化, 存放在 .bss 段
    
    cout << c << endl;  // 不为 0, 输出为栈上的无效值
    cout << g << endl;  // 一定为 0, 内核会将 .bss 段内容置 0 
    
    return 0;
}
```

任何的编程语言, 产生两种东西：指令、数据。

编译链接完成后, 产生可执行文件 (如 .exe 文件) , 存储于磁盘中; 运行时, 加载至内存当中 (不可能直接加载到物理内存) , 以 Linux 32 位系统为例, 首先会给当前进程分配 $2^{32}$  (4G) 大小的空间【进程的虚拟地址空间】,    (程序运行时, 内核会给当前进程开辟一块 $2^{32}$ 大小的虚拟地址空间, 从底层上看, 虚拟地址空间是内核创建的数据结构) , 每一个进程都有一个虚拟地址空间。

> 它存在, 你能看得见, 它是物理的; 
>
> 它存在, 你看不见, 它是透明的; 
>
> 它不存在, 你却看得见, 它是虚拟的; 
>
> 它不存在, 你也看不见, 它被删除了。
>
> ——IBM 解释虚拟内存

 虚拟地址空间默认划分为两部分：kernel space 内核空间、user space 用户空间。

每一个进程的用户空间是私有的, 但是内核空间是共享的。 (进程之间的通信方式, 匿名管道通信, 在内核空间划分一块内存, 不同进程读写实现进程间通信) 

32 位

+ 用户空间：0x00000000~0xC0000000(3G)。
  + 0x00000000~0x08048000 为预留空间, 无法访问。访问空指针 nullptr 即 0 地址, 程序直接挂掉, 因为这块空间不允许访问; 
  + **.text 代码段** (存放指令) , 均不允许写, 只能读; 
  + **.rodata 只读数据段**（存放 如常量字符串 `char *p = "hello world";` 中的 `hello world`）, 均不允许写, 只能读; 
  + .data, 存放初始化, 且初始化不为 0 的数据; 
  + .bss, 存放未初始化 (操作系统默认对其 0 初始化) , 以及初始化为 0 的数据; 
  + .heap, 程序运行时调用 new 或 malloc 才会产生, 从低地址到高地址生长; 
  + 当前程序运行过程中会加载的共享库, 动态链接库 (.dll  .so) ; 
  + stack, 从高地址到低地址生长; 
  + 存放命令行参数和环境变量; 
+ 内核空间：0xC0000000~0xFFFFFFFF
  + ZONE_DMA, 16M
  + ZONE_NORMAL, 800M+, 进程控制块等
  + ZONE_HIGHMEM



<img src="./assets/Linux x86-64 运行时内存映射.png" alt="Linux x86-64 运行时内存映射" style="zoom:50%;" />

<img src="./assets/Linux x86-32 运行时内存映射.png" alt="Linux x86-64 运行时内存映射" style="zoom:50%;" />

