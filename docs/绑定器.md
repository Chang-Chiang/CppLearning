# 绑定器

## STL 中的绑定器

+ bind1st : operator() 的第一个形参变量绑定成一个确定的值
+ bind2nd : operator() 的第一个形参变量绑定成一个确定的值

## 示例

+ `sort()` 算法需要一个二元函数对象，决定排序顺序
+ `find_if()` 算法需要一个一元函数对象，用于与迭代器比较大小
+ `bind1st()` 或 `bind2nd()` 用于将一个二元函数对象绑定为一元函数对象，传给 `find_if()` 算法

```c++
#include <algorithm>  // 泛型算法
#include <ctime>
#include <functional> // 函数对象
#include <iostream>
#include <vector>
using namespace std;

template <typename Container>
void showContainer(Container& con) {
    // Container::iterator it = con.begin();
    // Container 类型还未实例化, 编译器不知道 Container::iterator 是类型还是变量

    typename Container::iterator it = con.begin();
    // 告诉编译器 Container::iterator 是类型

    for (; it != con.end(); ++it) {
        cout << *it << " ";
    }
    cout << endl;
}

int main() {
    vector<int> vec;
    srand(time(nullptr));
    for (int i = 0; i < 20; ++i) {
        vec.push_back(rand() % 100 + 1);
    }

    showContainer(vec);
    sort(vec.begin(), vec.end()); // 默认小到大排序
    showContainer(vec);

    // greater 二元函数对象
    sort(vec.begin(), vec.end(), greater<int>()); // 重载 从大到小排序
    showContainer(vec);

    /*
    把 70 按顺序插入到 vec 容器当中
    operator()(const T &val), find_if 需要 一元函数对象
    greater a > b
    less    a < b
    绑定器 + 二元函数对象 => 一元函数对象
    bool operator()(const _Ty &_Left, const _Ty &_Right)
    bind1st + greater => bool operator()(70, const _Ty &_Right)
    bind2nd + less    => bool operator()(const _Ty &_Left, 70)
    */
    auto it1 = find_if(vec.begin(), vec.end(), bind1st(greater<int>(), 70));
    // auto it1 = find_if(vec.begin(), vec.end(), bind2nd(less<int>(), 70));
    if (it1 != vec.end()) {
        vec.insert(it1, 70);
    }
    showContainer(vec);

    return 0;
}
```

## 绑定器底层原理实现

> 实现 `find_if()` 算法 和 `bind1st()` 绑定器 

```c++
template <typename Iterator, typename Compare> // 迭代器类型, 函数对象
Iterator my_find_if(Iterator first, Iterator last, Compare comp) {
    for (; first != last; ++first) {
        if (comp(*first)) { // comp.operator()(*first)
            return first;
        }
    }
    return last;
}

template <typename Compare, typename T>
class _mybind1st { // 绑定器是函数对象的一个应用
    public;
    _mybind1st(Compare comp, T val) : _comp(comp), _val(val) {}
    bool operator()(const T& second) { return _comp(_val, second); }

private:
    Compare _comp;
    T       _val;
};

template <typename Compare, typename T> // 二元函数对象, 元素类型
_mybind1st<Compare, T> mybind1st(Compare comp, const T& val) {
    // 直接使用函数模板, 好处是, 可以进行类型的推演
    return _mybind1st<Compare, T>(comp, val); // 返回一元函数对象
}
```

## C++11 bind

> + C++ 11 从 Boost 库中引入了 bind 绑定器和 function 函数对象机制
>
> + C++11 bind绑定器返回的结果还是一个函数对象
